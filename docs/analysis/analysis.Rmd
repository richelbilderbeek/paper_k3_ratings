---
title: "Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analysis}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this document, we do the analysis presented in the paper.

Currently, the analysis uses fake data.

## Setup

```{r}
library(testthat)
```

## Reading the data

```{r}
ratings <- readr::read_csv("ratings.csv", show_col_types = FALSE)
n_ratings <- nrow(ratings)
```

There are `r n_ratings` ratings.

## Analysis

Connecting the ratings to the formations:

```{r}
songs <- dplyr::select(heyahmama::get_songs(), cd_title, song_title)
n_songs <- nrow(songs)
```

There are `r n_songs` songs.

```{r}
cds <- dplyr::select(heyahmama::get_cds(), cd_title, formation)
n_cds <- nrow(cds)
n_formations <- length(unique(cds$formation))
```

There are `r n_cds` CDs.

```{r}
songs_per_formation <- dplyr::select(merge(songs, cds), song_title, formation)
testthat::expect_equal(n_songs, nrow(songs_per_formation))
knitr::kable(head(songs_per_formation))
```

Add the formations to the ratings:

```{r}
ratings_per_formation <- dplyr::select(merge(ratings, songs_per_formation), formation, rating)
testthat::expect_equal(n_ratings, nrow(ratings_per_formation))
ratings_per_formation$formation <- as.factor(ratings_per_formation$formation)
knitr::kable(head(ratings_per_formation))
```

## Formations

There are two datasets:

- Dataset A: all 4 formations
- Dataset B: the first 3 formations

## 4 formations

Plot:


```{r}
p <- ggplot2::ggplot(
  ratings_per_formation,
  ggplot2::aes(x = formation, y = rating)
) + ggplot2::geom_violin()
p
```

Order formations by ratings:

```{r}
average_rating_per_formation <-
  ratings_per_formation |> 
  dplyr::group_by(formation) |> 
  dplyr::summarise(average_rating = mean(rating))
testthat::expect_equal(n_formations, nrow(average_rating_per_formation))

ordered_average_rating_per_formation <- 
  average_rating_per_formation |> 
  dplyr::arrange(dplyr::desc(average_rating))
testthat::expect_equal(n_formations, nrow(ordered_average_rating_per_formation))

knitr::kable(ordered_average_rating_per_formation)
```

## Statistics

Do the formations have different ratings?

```{r}
n_combinations <- factorial(n_formations - 1)
```

There will be `r n_combinations` comparisons.

```{r}
alpha <- 0.05 / n_combinations
```

Due to `r n_combinations` comparisons,
the alpha value is (`0.05` divided by
`r n_combinations` equals) `r alpha`.

```{r}
p_values_table <- tibble::tibble(
  a = rep(NA, n_combinations), 
  b = NA, 
  p_value = NA
)

i <- 1
for (lhs in seq(1, n_formations - 1)) {
  ratings_lhs <- ratings_per_formation[ratings_per_formation$formation == lhs, ]$rating
  for (rhs in seq(lhs + 1, n_formations)) {
    ratings_rhs <- ratings_per_formation[ratings_per_formation$formation == rhs, ]$rating
    p_value <- wilcox.test(ratings_lhs, ratings_rhs, alternative = "two.sided")$p.value
    testthat::expect_true(i >= 1)
    testthat::expect_true(i <= nrow(p_values_table))
    p_values_table$a[i] <- lhs
    p_values_table$b[i] <- rhs
    p_values_table$p_value[i] <- p_value
    i <- i + 1
  }
}
p_values_table$is_the_same <- p_values_table$p_value > alpha
knitr::kable(p_values_table)
```



```{r}
library(ggsignif)

plot_p_values_table <- p_values_table[p_values_table$is_the_same == FALSE, ]

plot_p_values_table$annotation <- scales::scientific(plot_p_values_table$p_value, digits = 1)
plot_p_values_table$a <- as.factor(plot_p_values_table$a)
plot_p_values_table$b <- as.factor(plot_p_values_table$b)
plot_p_values_table$y_position <- seq(
  from = 11.0, 
  to = 11.0 + ((nrow(plot_p_values_table) - 1) * 2.0),
  by = 2.0
)
p + ggsignif::geom_signif(
  data = plot_p_values_table,
  ggplot2::aes(
    xmin = a,
    xmax = b,
    annotations = annotation,
    y_position = y_position
  ),
  manual = TRUE
)
```
